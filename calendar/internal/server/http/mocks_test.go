// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package http

import (
	"github.com/Roma7-7-7/workshops/calendar/internal/models"
	"github.com/gin-gonic/gin"
	"sync"
	"time"
)

// Ensure, that ValidatorMock does implement Validator.
// If this is not the case, regenerate this file with moq.
var _ Validator = &ValidatorMock{}

// ValidatorMock is a mock implementation of Validator.
//
// 	func TestSomethingThatUsesValidator(t *testing.T) {
//
// 		// make and configure a mocked Validator
// 		mockedValidator := &ValidatorMock{
// 			ValidateFunc: func(ifaceVal interface{}) error {
// 				panic("mock out the Validate method")
// 			},
// 		}
//
// 		// use mockedValidator in code that requires Validator
// 		// and then make assertions.
//
// 	}
type ValidatorMock struct {
	// ValidateFunc mocks the Validate method.
	ValidateFunc func(ifaceVal interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Validate holds details about calls to the Validate method.
		Validate []struct {
			// IfaceVal is the ifaceVal argument value.
			IfaceVal interface{}
		}
	}
	lockValidate sync.RWMutex
}

// Validate calls ValidateFunc.
func (mock *ValidatorMock) Validate(ifaceVal interface{}) error {
	if mock.ValidateFunc == nil {
		panic("ValidatorMock.ValidateFunc: method is nil but Validator.Validate was just called")
	}
	callInfo := struct {
		IfaceVal interface{}
	}{
		IfaceVal: ifaceVal,
	}
	mock.lockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	mock.lockValidate.Unlock()
	return mock.ValidateFunc(ifaceVal)
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//     len(mockedValidator.ValidateCalls())
func (mock *ValidatorMock) ValidateCalls() []struct {
	IfaceVal interface{}
} {
	var calls []struct {
		IfaceVal interface{}
	}
	mock.lockValidate.RLock()
	calls = mock.calls.Validate
	mock.lockValidate.RUnlock()
	return calls
}

// Ensure, that ServiceMock does implement Service.
// If this is not the case, regenerate this file with moq.
var _ Service = &ServiceMock{}

// ServiceMock is a mock implementation of Service.
//
// 	func TestSomethingThatUsesService(t *testing.T) {
//
// 		// make and configure a mocked Service
// 		mockedService := &ServiceMock{
// 			CreateEventFunc: func(username string, title string, description string, timeVal string, timezone string, duration time.Duration, notes []string) (*models.Event, error) {
// 				panic("mock out the CreateEvent method")
// 			},
// 			DeleteEventFunc: func(id string) (bool, error) {
// 				panic("mock out the DeleteEvent method")
// 			},
// 			GetEventFunc: func(id string) (*models.Event, error) {
// 				panic("mock out the GetEvent method")
// 			},
// 			GetEventOwnerFunc: func(id string) (string, error) {
// 				panic("mock out the GetEventOwner method")
// 			},
// 			GetEventsFunc: func(username string, title string, dateFrom string, timeFrom string, dateTo string, timeTo string, timezone string) ([]*models.Event, error) {
// 				panic("mock out the GetEvents method")
// 			},
// 			GetEventsCountFunc: func() (int, error) {
// 				panic("mock out the GetEventsCount method")
// 			},
// 			GetUsersCountFunc: func() (int, error) {
// 				panic("mock out the GetUsersCount method")
// 			},
// 			UpdateEventFunc: func(id string, title string, description string, timeVal string, timezone string, duration time.Duration, notes []string) (*models.Event, error) {
// 				panic("mock out the UpdateEvent method")
// 			},
// 			UpdateUserTimezoneFunc: func(username string, timezone string) (*models.User, error) {
// 				panic("mock out the UpdateUserTimezone method")
// 			},
// 		}
//
// 		// use mockedService in code that requires Service
// 		// and then make assertions.
//
// 	}
type ServiceMock struct {
	// CreateEventFunc mocks the CreateEvent method.
	CreateEventFunc func(username string, title string, description string, timeVal string, timezone string, duration time.Duration, notes []string) (*models.Event, error)

	// DeleteEventFunc mocks the DeleteEvent method.
	DeleteEventFunc func(id string) (bool, error)

	// GetEventFunc mocks the GetEvent method.
	GetEventFunc func(id string) (*models.Event, error)

	// GetEventOwnerFunc mocks the GetEventOwner method.
	GetEventOwnerFunc func(id string) (string, error)

	// GetEventsFunc mocks the GetEvents method.
	GetEventsFunc func(username string, title string, dateFrom string, timeFrom string, dateTo string, timeTo string, timezone string) ([]*models.Event, error)

	// GetEventsCountFunc mocks the GetEventsCount method.
	GetEventsCountFunc func() (int, error)

	// GetUsersCountFunc mocks the GetUsersCount method.
	GetUsersCountFunc func() (int, error)

	// UpdateEventFunc mocks the UpdateEvent method.
	UpdateEventFunc func(id string, title string, description string, timeVal string, timezone string, duration time.Duration, notes []string) (*models.Event, error)

	// UpdateUserTimezoneFunc mocks the UpdateUserTimezone method.
	UpdateUserTimezoneFunc func(username string, timezone string) (*models.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateEvent holds details about calls to the CreateEvent method.
		CreateEvent []struct {
			// Username is the username argument value.
			Username string
			// Title is the title argument value.
			Title string
			// Description is the description argument value.
			Description string
			// TimeVal is the timeVal argument value.
			TimeVal string
			// Timezone is the timezone argument value.
			Timezone string
			// Duration is the duration argument value.
			Duration time.Duration
			// Notes is the notes argument value.
			Notes []string
		}
		// DeleteEvent holds details about calls to the DeleteEvent method.
		DeleteEvent []struct {
			// ID is the id argument value.
			ID string
		}
		// GetEvent holds details about calls to the GetEvent method.
		GetEvent []struct {
			// ID is the id argument value.
			ID string
		}
		// GetEventOwner holds details about calls to the GetEventOwner method.
		GetEventOwner []struct {
			// ID is the id argument value.
			ID string
		}
		// GetEvents holds details about calls to the GetEvents method.
		GetEvents []struct {
			// Username is the username argument value.
			Username string
			// Title is the title argument value.
			Title string
			// DateFrom is the dateFrom argument value.
			DateFrom string
			// TimeFrom is the timeFrom argument value.
			TimeFrom string
			// DateTo is the dateTo argument value.
			DateTo string
			// TimeTo is the timeTo argument value.
			TimeTo string
			// Timezone is the timezone argument value.
			Timezone string
		}
		// GetEventsCount holds details about calls to the GetEventsCount method.
		GetEventsCount []struct {
		}
		// GetUsersCount holds details about calls to the GetUsersCount method.
		GetUsersCount []struct {
		}
		// UpdateEvent holds details about calls to the UpdateEvent method.
		UpdateEvent []struct {
			// ID is the id argument value.
			ID string
			// Title is the title argument value.
			Title string
			// Description is the description argument value.
			Description string
			// TimeVal is the timeVal argument value.
			TimeVal string
			// Timezone is the timezone argument value.
			Timezone string
			// Duration is the duration argument value.
			Duration time.Duration
			// Notes is the notes argument value.
			Notes []string
		}
		// UpdateUserTimezone holds details about calls to the UpdateUserTimezone method.
		UpdateUserTimezone []struct {
			// Username is the username argument value.
			Username string
			// Timezone is the timezone argument value.
			Timezone string
		}
	}
	lockCreateEvent        sync.RWMutex
	lockDeleteEvent        sync.RWMutex
	lockGetEvent           sync.RWMutex
	lockGetEventOwner      sync.RWMutex
	lockGetEvents          sync.RWMutex
	lockGetEventsCount     sync.RWMutex
	lockGetUsersCount      sync.RWMutex
	lockUpdateEvent        sync.RWMutex
	lockUpdateUserTimezone sync.RWMutex
}

// CreateEvent calls CreateEventFunc.
func (mock *ServiceMock) CreateEvent(username string, title string, description string, timeVal string, timezone string, duration time.Duration, notes []string) (*models.Event, error) {
	if mock.CreateEventFunc == nil {
		panic("ServiceMock.CreateEventFunc: method is nil but Service.CreateEvent was just called")
	}
	callInfo := struct {
		Username    string
		Title       string
		Description string
		TimeVal     string
		Timezone    string
		Duration    time.Duration
		Notes       []string
	}{
		Username:    username,
		Title:       title,
		Description: description,
		TimeVal:     timeVal,
		Timezone:    timezone,
		Duration:    duration,
		Notes:       notes,
	}
	mock.lockCreateEvent.Lock()
	mock.calls.CreateEvent = append(mock.calls.CreateEvent, callInfo)
	mock.lockCreateEvent.Unlock()
	return mock.CreateEventFunc(username, title, description, timeVal, timezone, duration, notes)
}

// CreateEventCalls gets all the calls that were made to CreateEvent.
// Check the length with:
//     len(mockedService.CreateEventCalls())
func (mock *ServiceMock) CreateEventCalls() []struct {
	Username    string
	Title       string
	Description string
	TimeVal     string
	Timezone    string
	Duration    time.Duration
	Notes       []string
} {
	var calls []struct {
		Username    string
		Title       string
		Description string
		TimeVal     string
		Timezone    string
		Duration    time.Duration
		Notes       []string
	}
	mock.lockCreateEvent.RLock()
	calls = mock.calls.CreateEvent
	mock.lockCreateEvent.RUnlock()
	return calls
}

// DeleteEvent calls DeleteEventFunc.
func (mock *ServiceMock) DeleteEvent(id string) (bool, error) {
	if mock.DeleteEventFunc == nil {
		panic("ServiceMock.DeleteEventFunc: method is nil but Service.DeleteEvent was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockDeleteEvent.Lock()
	mock.calls.DeleteEvent = append(mock.calls.DeleteEvent, callInfo)
	mock.lockDeleteEvent.Unlock()
	return mock.DeleteEventFunc(id)
}

// DeleteEventCalls gets all the calls that were made to DeleteEvent.
// Check the length with:
//     len(mockedService.DeleteEventCalls())
func (mock *ServiceMock) DeleteEventCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockDeleteEvent.RLock()
	calls = mock.calls.DeleteEvent
	mock.lockDeleteEvent.RUnlock()
	return calls
}

// GetEvent calls GetEventFunc.
func (mock *ServiceMock) GetEvent(id string) (*models.Event, error) {
	if mock.GetEventFunc == nil {
		panic("ServiceMock.GetEventFunc: method is nil but Service.GetEvent was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockGetEvent.Lock()
	mock.calls.GetEvent = append(mock.calls.GetEvent, callInfo)
	mock.lockGetEvent.Unlock()
	return mock.GetEventFunc(id)
}

// GetEventCalls gets all the calls that were made to GetEvent.
// Check the length with:
//     len(mockedService.GetEventCalls())
func (mock *ServiceMock) GetEventCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockGetEvent.RLock()
	calls = mock.calls.GetEvent
	mock.lockGetEvent.RUnlock()
	return calls
}

// GetEventOwner calls GetEventOwnerFunc.
func (mock *ServiceMock) GetEventOwner(id string) (string, error) {
	if mock.GetEventOwnerFunc == nil {
		panic("ServiceMock.GetEventOwnerFunc: method is nil but Service.GetEventOwner was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockGetEventOwner.Lock()
	mock.calls.GetEventOwner = append(mock.calls.GetEventOwner, callInfo)
	mock.lockGetEventOwner.Unlock()
	return mock.GetEventOwnerFunc(id)
}

// GetEventOwnerCalls gets all the calls that were made to GetEventOwner.
// Check the length with:
//     len(mockedService.GetEventOwnerCalls())
func (mock *ServiceMock) GetEventOwnerCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockGetEventOwner.RLock()
	calls = mock.calls.GetEventOwner
	mock.lockGetEventOwner.RUnlock()
	return calls
}

// GetEvents calls GetEventsFunc.
func (mock *ServiceMock) GetEvents(username string, title string, dateFrom string, timeFrom string, dateTo string, timeTo string, timezone string) ([]*models.Event, error) {
	if mock.GetEventsFunc == nil {
		panic("ServiceMock.GetEventsFunc: method is nil but Service.GetEvents was just called")
	}
	callInfo := struct {
		Username string
		Title    string
		DateFrom string
		TimeFrom string
		DateTo   string
		TimeTo   string
		Timezone string
	}{
		Username: username,
		Title:    title,
		DateFrom: dateFrom,
		TimeFrom: timeFrom,
		DateTo:   dateTo,
		TimeTo:   timeTo,
		Timezone: timezone,
	}
	mock.lockGetEvents.Lock()
	mock.calls.GetEvents = append(mock.calls.GetEvents, callInfo)
	mock.lockGetEvents.Unlock()
	return mock.GetEventsFunc(username, title, dateFrom, timeFrom, dateTo, timeTo, timezone)
}

// GetEventsCalls gets all the calls that were made to GetEvents.
// Check the length with:
//     len(mockedService.GetEventsCalls())
func (mock *ServiceMock) GetEventsCalls() []struct {
	Username string
	Title    string
	DateFrom string
	TimeFrom string
	DateTo   string
	TimeTo   string
	Timezone string
} {
	var calls []struct {
		Username string
		Title    string
		DateFrom string
		TimeFrom string
		DateTo   string
		TimeTo   string
		Timezone string
	}
	mock.lockGetEvents.RLock()
	calls = mock.calls.GetEvents
	mock.lockGetEvents.RUnlock()
	return calls
}

// GetEventsCount calls GetEventsCountFunc.
func (mock *ServiceMock) GetEventsCount() (int, error) {
	if mock.GetEventsCountFunc == nil {
		panic("ServiceMock.GetEventsCountFunc: method is nil but Service.GetEventsCount was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetEventsCount.Lock()
	mock.calls.GetEventsCount = append(mock.calls.GetEventsCount, callInfo)
	mock.lockGetEventsCount.Unlock()
	return mock.GetEventsCountFunc()
}

// GetEventsCountCalls gets all the calls that were made to GetEventsCount.
// Check the length with:
//     len(mockedService.GetEventsCountCalls())
func (mock *ServiceMock) GetEventsCountCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetEventsCount.RLock()
	calls = mock.calls.GetEventsCount
	mock.lockGetEventsCount.RUnlock()
	return calls
}

// GetUsersCount calls GetUsersCountFunc.
func (mock *ServiceMock) GetUsersCount() (int, error) {
	if mock.GetUsersCountFunc == nil {
		panic("ServiceMock.GetUsersCountFunc: method is nil but Service.GetUsersCount was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetUsersCount.Lock()
	mock.calls.GetUsersCount = append(mock.calls.GetUsersCount, callInfo)
	mock.lockGetUsersCount.Unlock()
	return mock.GetUsersCountFunc()
}

// GetUsersCountCalls gets all the calls that were made to GetUsersCount.
// Check the length with:
//     len(mockedService.GetUsersCountCalls())
func (mock *ServiceMock) GetUsersCountCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetUsersCount.RLock()
	calls = mock.calls.GetUsersCount
	mock.lockGetUsersCount.RUnlock()
	return calls
}

// UpdateEvent calls UpdateEventFunc.
func (mock *ServiceMock) UpdateEvent(id string, title string, description string, timeVal string, timezone string, duration time.Duration, notes []string) (*models.Event, error) {
	if mock.UpdateEventFunc == nil {
		panic("ServiceMock.UpdateEventFunc: method is nil but Service.UpdateEvent was just called")
	}
	callInfo := struct {
		ID          string
		Title       string
		Description string
		TimeVal     string
		Timezone    string
		Duration    time.Duration
		Notes       []string
	}{
		ID:          id,
		Title:       title,
		Description: description,
		TimeVal:     timeVal,
		Timezone:    timezone,
		Duration:    duration,
		Notes:       notes,
	}
	mock.lockUpdateEvent.Lock()
	mock.calls.UpdateEvent = append(mock.calls.UpdateEvent, callInfo)
	mock.lockUpdateEvent.Unlock()
	return mock.UpdateEventFunc(id, title, description, timeVal, timezone, duration, notes)
}

// UpdateEventCalls gets all the calls that were made to UpdateEvent.
// Check the length with:
//     len(mockedService.UpdateEventCalls())
func (mock *ServiceMock) UpdateEventCalls() []struct {
	ID          string
	Title       string
	Description string
	TimeVal     string
	Timezone    string
	Duration    time.Duration
	Notes       []string
} {
	var calls []struct {
		ID          string
		Title       string
		Description string
		TimeVal     string
		Timezone    string
		Duration    time.Duration
		Notes       []string
	}
	mock.lockUpdateEvent.RLock()
	calls = mock.calls.UpdateEvent
	mock.lockUpdateEvent.RUnlock()
	return calls
}

// UpdateUserTimezone calls UpdateUserTimezoneFunc.
func (mock *ServiceMock) UpdateUserTimezone(username string, timezone string) (*models.User, error) {
	if mock.UpdateUserTimezoneFunc == nil {
		panic("ServiceMock.UpdateUserTimezoneFunc: method is nil but Service.UpdateUserTimezone was just called")
	}
	callInfo := struct {
		Username string
		Timezone string
	}{
		Username: username,
		Timezone: timezone,
	}
	mock.lockUpdateUserTimezone.Lock()
	mock.calls.UpdateUserTimezone = append(mock.calls.UpdateUserTimezone, callInfo)
	mock.lockUpdateUserTimezone.Unlock()
	return mock.UpdateUserTimezoneFunc(username, timezone)
}

// UpdateUserTimezoneCalls gets all the calls that were made to UpdateUserTimezone.
// Check the length with:
//     len(mockedService.UpdateUserTimezoneCalls())
func (mock *ServiceMock) UpdateUserTimezoneCalls() []struct {
	Username string
	Timezone string
} {
	var calls []struct {
		Username string
		Timezone string
	}
	mock.lockUpdateUserTimezone.RLock()
	calls = mock.calls.UpdateUserTimezone
	mock.lockUpdateUserTimezone.RUnlock()
	return calls
}

// Ensure, that AuthMock does implement Auth.
// If this is not the case, regenerate this file with moq.
var _ Auth = &AuthMock{}

// AuthMock is a mock implementation of Auth.
//
// 	func TestSomethingThatUsesAuth(t *testing.T) {
//
// 		// make and configure a mocked Auth
// 		mockedAuth := &AuthMock{
// 			LoginFunc: func(c *gin.Context)  {
// 				panic("mock out the Login method")
// 			},
// 			LogoutFunc: func(c *gin.Context)  {
// 				panic("mock out the Logout method")
// 			},
// 			ValidateFunc: func(c *gin.Context)  {
// 				panic("mock out the Validate method")
// 			},
// 		}
//
// 		// use mockedAuth in code that requires Auth
// 		// and then make assertions.
//
// 	}
type AuthMock struct {
	// LoginFunc mocks the Login method.
	LoginFunc func(c *gin.Context)

	// LogoutFunc mocks the Logout method.
	LogoutFunc func(c *gin.Context)

	// ValidateFunc mocks the Validate method.
	ValidateFunc func(c *gin.Context)

	// calls tracks calls to the methods.
	calls struct {
		// Login holds details about calls to the Login method.
		Login []struct {
			// C is the c argument value.
			C *gin.Context
		}
		// Logout holds details about calls to the Logout method.
		Logout []struct {
			// C is the c argument value.
			C *gin.Context
		}
		// Validate holds details about calls to the Validate method.
		Validate []struct {
			// C is the c argument value.
			C *gin.Context
		}
	}
	lockLogin    sync.RWMutex
	lockLogout   sync.RWMutex
	lockValidate sync.RWMutex
}

// Login calls LoginFunc.
func (mock *AuthMock) Login(c *gin.Context) {
	if mock.LoginFunc == nil {
		panic("AuthMock.LoginFunc: method is nil but Auth.Login was just called")
	}
	callInfo := struct {
		C *gin.Context
	}{
		C: c,
	}
	mock.lockLogin.Lock()
	mock.calls.Login = append(mock.calls.Login, callInfo)
	mock.lockLogin.Unlock()
	mock.LoginFunc(c)
}

// LoginCalls gets all the calls that were made to Login.
// Check the length with:
//     len(mockedAuth.LoginCalls())
func (mock *AuthMock) LoginCalls() []struct {
	C *gin.Context
} {
	var calls []struct {
		C *gin.Context
	}
	mock.lockLogin.RLock()
	calls = mock.calls.Login
	mock.lockLogin.RUnlock()
	return calls
}

// Logout calls LogoutFunc.
func (mock *AuthMock) Logout(c *gin.Context) {
	if mock.LogoutFunc == nil {
		panic("AuthMock.LogoutFunc: method is nil but Auth.Logout was just called")
	}
	callInfo := struct {
		C *gin.Context
	}{
		C: c,
	}
	mock.lockLogout.Lock()
	mock.calls.Logout = append(mock.calls.Logout, callInfo)
	mock.lockLogout.Unlock()
	mock.LogoutFunc(c)
}

// LogoutCalls gets all the calls that were made to Logout.
// Check the length with:
//     len(mockedAuth.LogoutCalls())
func (mock *AuthMock) LogoutCalls() []struct {
	C *gin.Context
} {
	var calls []struct {
		C *gin.Context
	}
	mock.lockLogout.RLock()
	calls = mock.calls.Logout
	mock.lockLogout.RUnlock()
	return calls
}

// Validate calls ValidateFunc.
func (mock *AuthMock) Validate(c *gin.Context) {
	if mock.ValidateFunc == nil {
		panic("AuthMock.ValidateFunc: method is nil but Auth.Validate was just called")
	}
	callInfo := struct {
		C *gin.Context
	}{
		C: c,
	}
	mock.lockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	mock.lockValidate.Unlock()
	mock.ValidateFunc(c)
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//     len(mockedAuth.ValidateCalls())
func (mock *AuthMock) ValidateCalls() []struct {
	C *gin.Context
} {
	var calls []struct {
		C *gin.Context
	}
	mock.lockValidate.RLock()
	calls = mock.calls.Validate
	mock.lockValidate.RUnlock()
	return calls
}
