// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package calendar

import (
	"github.com/Roma7-7-7/workshops/calendar/internal/models"
	"sync"
	"time"
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
// 	func TestSomethingThatUsesRepository(t *testing.T) {
//
// 		// make and configure a mocked Repository
// 		mockedRepository := &RepositoryMock{
// 			CreateEventFunc: func(username string, title string, description string, from time.Time, to time.Time, notes []string) (*models.Event, error) {
// 				panic("mock out the CreateEvent method")
// 			},
// 			DeleteEventFunc: func(id string) (bool, error) {
// 				panic("mock out the DeleteEvent method")
// 			},
// 			EventExistsFunc: func(id string) (bool, error) {
// 				panic("mock out the EventExists method")
// 			},
// 			GetEventFunc: func(id string) (*models.Event, error) {
// 				panic("mock out the GetEvent method")
// 			},
// 			GetEventOwnerFunc: func(eventId string) (string, error) {
// 				panic("mock out the GetEventOwner method")
// 			},
// 			GetEventsFunc: func(username string, title string, dateFrom string, timeFrom string, dateTo string, timeTo string) ([]*models.Event, error) {
// 				panic("mock out the GetEvents method")
// 			},
// 			GetEventsCountFunc: func() (int, error) {
// 				panic("mock out the GetEventsCount method")
// 			},
// 			GetUserFunc: func(username string) (*models.User, error) {
// 				panic("mock out the GetUser method")
// 			},
// 			GetUsersCountFunc: func() (int, error) {
// 				panic("mock out the GetUsersCount method")
// 			},
// 			UpdateEventFunc: func(id string, title string, description string, from time.Time, to time.Time, notes []string) (*models.Event, error) {
// 				panic("mock out the UpdateEvent method")
// 			},
// 			UpdateUserTimezoneFunc: func(username string, timezone string) (*models.User, error) {
// 				panic("mock out the UpdateUserTimezone method")
// 			},
// 		}
//
// 		// use mockedRepository in code that requires Repository
// 		// and then make assertions.
//
// 	}
type RepositoryMock struct {
	// CreateEventFunc mocks the CreateEvent method.
	CreateEventFunc func(username string, title string, description string, from time.Time, to time.Time, notes []string) (*models.Event, error)

	// DeleteEventFunc mocks the DeleteEvent method.
	DeleteEventFunc func(id string) (bool, error)

	// EventExistsFunc mocks the EventExists method.
	EventExistsFunc func(id string) (bool, error)

	// GetEventFunc mocks the GetEvent method.
	GetEventFunc func(id string) (*models.Event, error)

	// GetEventOwnerFunc mocks the GetEventOwner method.
	GetEventOwnerFunc func(eventId string) (string, error)

	// GetEventsFunc mocks the GetEvents method.
	GetEventsFunc func(username string, title string, dateFrom string, timeFrom string, dateTo string, timeTo string) ([]*models.Event, error)

	// GetEventsCountFunc mocks the GetEventsCount method.
	GetEventsCountFunc func() (int, error)

	// GetUserFunc mocks the GetUser method.
	GetUserFunc func(username string) (*models.User, error)

	// GetUsersCountFunc mocks the GetUsersCount method.
	GetUsersCountFunc func() (int, error)

	// UpdateEventFunc mocks the UpdateEvent method.
	UpdateEventFunc func(id string, title string, description string, from time.Time, to time.Time, notes []string) (*models.Event, error)

	// UpdateUserTimezoneFunc mocks the UpdateUserTimezone method.
	UpdateUserTimezoneFunc func(username string, timezone string) (*models.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateEvent holds details about calls to the CreateEvent method.
		CreateEvent []struct {
			// Username is the username argument value.
			Username string
			// Title is the title argument value.
			Title string
			// Description is the description argument value.
			Description string
			// From is the from argument value.
			From time.Time
			// To is the to argument value.
			To time.Time
			// Notes is the notes argument value.
			Notes []string
		}
		// DeleteEvent holds details about calls to the DeleteEvent method.
		DeleteEvent []struct {
			// ID is the id argument value.
			ID string
		}
		// EventExists holds details about calls to the EventExists method.
		EventExists []struct {
			// ID is the id argument value.
			ID string
		}
		// GetEvent holds details about calls to the GetEvent method.
		GetEvent []struct {
			// ID is the id argument value.
			ID string
		}
		// GetEventOwner holds details about calls to the GetEventOwner method.
		GetEventOwner []struct {
			// EventId is the eventId argument value.
			EventId string
		}
		// GetEvents holds details about calls to the GetEvents method.
		GetEvents []struct {
			// Username is the username argument value.
			Username string
			// Title is the title argument value.
			Title string
			// DateFrom is the dateFrom argument value.
			DateFrom string
			// TimeFrom is the timeFrom argument value.
			TimeFrom string
			// DateTo is the dateTo argument value.
			DateTo string
			// TimeTo is the timeTo argument value.
			TimeTo string
		}
		// GetEventsCount holds details about calls to the GetEventsCount method.
		GetEventsCount []struct {
		}
		// GetUser holds details about calls to the GetUser method.
		GetUser []struct {
			// Username is the username argument value.
			Username string
		}
		// GetUsersCount holds details about calls to the GetUsersCount method.
		GetUsersCount []struct {
		}
		// UpdateEvent holds details about calls to the UpdateEvent method.
		UpdateEvent []struct {
			// ID is the id argument value.
			ID string
			// Title is the title argument value.
			Title string
			// Description is the description argument value.
			Description string
			// From is the from argument value.
			From time.Time
			// To is the to argument value.
			To time.Time
			// Notes is the notes argument value.
			Notes []string
		}
		// UpdateUserTimezone holds details about calls to the UpdateUserTimezone method.
		UpdateUserTimezone []struct {
			// Username is the username argument value.
			Username string
			// Timezone is the timezone argument value.
			Timezone string
		}
	}
	lockCreateEvent        sync.RWMutex
	lockDeleteEvent        sync.RWMutex
	lockEventExists        sync.RWMutex
	lockGetEvent           sync.RWMutex
	lockGetEventOwner      sync.RWMutex
	lockGetEvents          sync.RWMutex
	lockGetEventsCount     sync.RWMutex
	lockGetUser            sync.RWMutex
	lockGetUsersCount      sync.RWMutex
	lockUpdateEvent        sync.RWMutex
	lockUpdateUserTimezone sync.RWMutex
}

// CreateEvent calls CreateEventFunc.
func (mock *RepositoryMock) CreateEvent(username string, title string, description string, from time.Time, to time.Time, notes []string) (*models.Event, error) {
	if mock.CreateEventFunc == nil {
		panic("RepositoryMock.CreateEventFunc: method is nil but Repository.CreateEvent was just called")
	}
	callInfo := struct {
		Username    string
		Title       string
		Description string
		From        time.Time
		To          time.Time
		Notes       []string
	}{
		Username:    username,
		Title:       title,
		Description: description,
		From:        from,
		To:          to,
		Notes:       notes,
	}
	mock.lockCreateEvent.Lock()
	mock.calls.CreateEvent = append(mock.calls.CreateEvent, callInfo)
	mock.lockCreateEvent.Unlock()
	return mock.CreateEventFunc(username, title, description, from, to, notes)
}

// CreateEventCalls gets all the calls that were made to CreateEvent.
// Check the length with:
//     len(mockedRepository.CreateEventCalls())
func (mock *RepositoryMock) CreateEventCalls() []struct {
	Username    string
	Title       string
	Description string
	From        time.Time
	To          time.Time
	Notes       []string
} {
	var calls []struct {
		Username    string
		Title       string
		Description string
		From        time.Time
		To          time.Time
		Notes       []string
	}
	mock.lockCreateEvent.RLock()
	calls = mock.calls.CreateEvent
	mock.lockCreateEvent.RUnlock()
	return calls
}

// DeleteEvent calls DeleteEventFunc.
func (mock *RepositoryMock) DeleteEvent(id string) (bool, error) {
	if mock.DeleteEventFunc == nil {
		panic("RepositoryMock.DeleteEventFunc: method is nil but Repository.DeleteEvent was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockDeleteEvent.Lock()
	mock.calls.DeleteEvent = append(mock.calls.DeleteEvent, callInfo)
	mock.lockDeleteEvent.Unlock()
	return mock.DeleteEventFunc(id)
}

// DeleteEventCalls gets all the calls that were made to DeleteEvent.
// Check the length with:
//     len(mockedRepository.DeleteEventCalls())
func (mock *RepositoryMock) DeleteEventCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockDeleteEvent.RLock()
	calls = mock.calls.DeleteEvent
	mock.lockDeleteEvent.RUnlock()
	return calls
}

// EventExists calls EventExistsFunc.
func (mock *RepositoryMock) EventExists(id string) (bool, error) {
	if mock.EventExistsFunc == nil {
		panic("RepositoryMock.EventExistsFunc: method is nil but Repository.EventExists was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockEventExists.Lock()
	mock.calls.EventExists = append(mock.calls.EventExists, callInfo)
	mock.lockEventExists.Unlock()
	return mock.EventExistsFunc(id)
}

// EventExistsCalls gets all the calls that were made to EventExists.
// Check the length with:
//     len(mockedRepository.EventExistsCalls())
func (mock *RepositoryMock) EventExistsCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockEventExists.RLock()
	calls = mock.calls.EventExists
	mock.lockEventExists.RUnlock()
	return calls
}

// GetEvent calls GetEventFunc.
func (mock *RepositoryMock) GetEvent(id string) (*models.Event, error) {
	if mock.GetEventFunc == nil {
		panic("RepositoryMock.GetEventFunc: method is nil but Repository.GetEvent was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockGetEvent.Lock()
	mock.calls.GetEvent = append(mock.calls.GetEvent, callInfo)
	mock.lockGetEvent.Unlock()
	return mock.GetEventFunc(id)
}

// GetEventCalls gets all the calls that were made to GetEvent.
// Check the length with:
//     len(mockedRepository.GetEventCalls())
func (mock *RepositoryMock) GetEventCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockGetEvent.RLock()
	calls = mock.calls.GetEvent
	mock.lockGetEvent.RUnlock()
	return calls
}

// GetEventOwner calls GetEventOwnerFunc.
func (mock *RepositoryMock) GetEventOwner(eventId string) (string, error) {
	if mock.GetEventOwnerFunc == nil {
		panic("RepositoryMock.GetEventOwnerFunc: method is nil but Repository.GetEventOwner was just called")
	}
	callInfo := struct {
		EventId string
	}{
		EventId: eventId,
	}
	mock.lockGetEventOwner.Lock()
	mock.calls.GetEventOwner = append(mock.calls.GetEventOwner, callInfo)
	mock.lockGetEventOwner.Unlock()
	return mock.GetEventOwnerFunc(eventId)
}

// GetEventOwnerCalls gets all the calls that were made to GetEventOwner.
// Check the length with:
//     len(mockedRepository.GetEventOwnerCalls())
func (mock *RepositoryMock) GetEventOwnerCalls() []struct {
	EventId string
} {
	var calls []struct {
		EventId string
	}
	mock.lockGetEventOwner.RLock()
	calls = mock.calls.GetEventOwner
	mock.lockGetEventOwner.RUnlock()
	return calls
}

// GetEvents calls GetEventsFunc.
func (mock *RepositoryMock) GetEvents(username string, title string, dateFrom string, timeFrom string, dateTo string, timeTo string) ([]*models.Event, error) {
	if mock.GetEventsFunc == nil {
		panic("RepositoryMock.GetEventsFunc: method is nil but Repository.GetEvents was just called")
	}
	callInfo := struct {
		Username string
		Title    string
		DateFrom string
		TimeFrom string
		DateTo   string
		TimeTo   string
	}{
		Username: username,
		Title:    title,
		DateFrom: dateFrom,
		TimeFrom: timeFrom,
		DateTo:   dateTo,
		TimeTo:   timeTo,
	}
	mock.lockGetEvents.Lock()
	mock.calls.GetEvents = append(mock.calls.GetEvents, callInfo)
	mock.lockGetEvents.Unlock()
	return mock.GetEventsFunc(username, title, dateFrom, timeFrom, dateTo, timeTo)
}

// GetEventsCalls gets all the calls that were made to GetEvents.
// Check the length with:
//     len(mockedRepository.GetEventsCalls())
func (mock *RepositoryMock) GetEventsCalls() []struct {
	Username string
	Title    string
	DateFrom string
	TimeFrom string
	DateTo   string
	TimeTo   string
} {
	var calls []struct {
		Username string
		Title    string
		DateFrom string
		TimeFrom string
		DateTo   string
		TimeTo   string
	}
	mock.lockGetEvents.RLock()
	calls = mock.calls.GetEvents
	mock.lockGetEvents.RUnlock()
	return calls
}

// GetEventsCount calls GetEventsCountFunc.
func (mock *RepositoryMock) GetEventsCount() (int, error) {
	if mock.GetEventsCountFunc == nil {
		panic("RepositoryMock.GetEventsCountFunc: method is nil but Repository.GetEventsCount was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetEventsCount.Lock()
	mock.calls.GetEventsCount = append(mock.calls.GetEventsCount, callInfo)
	mock.lockGetEventsCount.Unlock()
	return mock.GetEventsCountFunc()
}

// GetEventsCountCalls gets all the calls that were made to GetEventsCount.
// Check the length with:
//     len(mockedRepository.GetEventsCountCalls())
func (mock *RepositoryMock) GetEventsCountCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetEventsCount.RLock()
	calls = mock.calls.GetEventsCount
	mock.lockGetEventsCount.RUnlock()
	return calls
}

// GetUser calls GetUserFunc.
func (mock *RepositoryMock) GetUser(username string) (*models.User, error) {
	if mock.GetUserFunc == nil {
		panic("RepositoryMock.GetUserFunc: method is nil but Repository.GetUser was just called")
	}
	callInfo := struct {
		Username string
	}{
		Username: username,
	}
	mock.lockGetUser.Lock()
	mock.calls.GetUser = append(mock.calls.GetUser, callInfo)
	mock.lockGetUser.Unlock()
	return mock.GetUserFunc(username)
}

// GetUserCalls gets all the calls that were made to GetUser.
// Check the length with:
//     len(mockedRepository.GetUserCalls())
func (mock *RepositoryMock) GetUserCalls() []struct {
	Username string
} {
	var calls []struct {
		Username string
	}
	mock.lockGetUser.RLock()
	calls = mock.calls.GetUser
	mock.lockGetUser.RUnlock()
	return calls
}

// GetUsersCount calls GetUsersCountFunc.
func (mock *RepositoryMock) GetUsersCount() (int, error) {
	if mock.GetUsersCountFunc == nil {
		panic("RepositoryMock.GetUsersCountFunc: method is nil but Repository.GetUsersCount was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetUsersCount.Lock()
	mock.calls.GetUsersCount = append(mock.calls.GetUsersCount, callInfo)
	mock.lockGetUsersCount.Unlock()
	return mock.GetUsersCountFunc()
}

// GetUsersCountCalls gets all the calls that were made to GetUsersCount.
// Check the length with:
//     len(mockedRepository.GetUsersCountCalls())
func (mock *RepositoryMock) GetUsersCountCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetUsersCount.RLock()
	calls = mock.calls.GetUsersCount
	mock.lockGetUsersCount.RUnlock()
	return calls
}

// UpdateEvent calls UpdateEventFunc.
func (mock *RepositoryMock) UpdateEvent(id string, title string, description string, from time.Time, to time.Time, notes []string) (*models.Event, error) {
	if mock.UpdateEventFunc == nil {
		panic("RepositoryMock.UpdateEventFunc: method is nil but Repository.UpdateEvent was just called")
	}
	callInfo := struct {
		ID          string
		Title       string
		Description string
		From        time.Time
		To          time.Time
		Notes       []string
	}{
		ID:          id,
		Title:       title,
		Description: description,
		From:        from,
		To:          to,
		Notes:       notes,
	}
	mock.lockUpdateEvent.Lock()
	mock.calls.UpdateEvent = append(mock.calls.UpdateEvent, callInfo)
	mock.lockUpdateEvent.Unlock()
	return mock.UpdateEventFunc(id, title, description, from, to, notes)
}

// UpdateEventCalls gets all the calls that were made to UpdateEvent.
// Check the length with:
//     len(mockedRepository.UpdateEventCalls())
func (mock *RepositoryMock) UpdateEventCalls() []struct {
	ID          string
	Title       string
	Description string
	From        time.Time
	To          time.Time
	Notes       []string
} {
	var calls []struct {
		ID          string
		Title       string
		Description string
		From        time.Time
		To          time.Time
		Notes       []string
	}
	mock.lockUpdateEvent.RLock()
	calls = mock.calls.UpdateEvent
	mock.lockUpdateEvent.RUnlock()
	return calls
}

// UpdateUserTimezone calls UpdateUserTimezoneFunc.
func (mock *RepositoryMock) UpdateUserTimezone(username string, timezone string) (*models.User, error) {
	if mock.UpdateUserTimezoneFunc == nil {
		panic("RepositoryMock.UpdateUserTimezoneFunc: method is nil but Repository.UpdateUserTimezone was just called")
	}
	callInfo := struct {
		Username string
		Timezone string
	}{
		Username: username,
		Timezone: timezone,
	}
	mock.lockUpdateUserTimezone.Lock()
	mock.calls.UpdateUserTimezone = append(mock.calls.UpdateUserTimezone, callInfo)
	mock.lockUpdateUserTimezone.Unlock()
	return mock.UpdateUserTimezoneFunc(username, timezone)
}

// UpdateUserTimezoneCalls gets all the calls that were made to UpdateUserTimezone.
// Check the length with:
//     len(mockedRepository.UpdateUserTimezoneCalls())
func (mock *RepositoryMock) UpdateUserTimezoneCalls() []struct {
	Username string
	Timezone string
} {
	var calls []struct {
		Username string
		Timezone string
	}
	mock.lockUpdateUserTimezone.RLock()
	calls = mock.calls.UpdateUserTimezone
	mock.lockUpdateUserTimezone.RUnlock()
	return calls
}
